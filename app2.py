# -*- coding: utf-8 -*-
"""app2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y3nKzTXEuoBKsqgD6UcDrrIqv7D1MqUw
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

br = pd.read_csv('/content/deliveries.csv', on_bad_lines='skip') # or on_bad_lines='warn'
br

# prompt: split the players

# Assuming 'br' DataFrame is already loaded as in the previous code.

# Group players by their batting position
batting_positions = br.groupby('batter')['batsman_runs'].sum()

# Filter for players with a significant number of runs (e.g., more than 1000 runs)
top_batsmen = batting_positions[batting_positions > 1000]

# Display the top batsmen and their total runs
print(top_batsmen)

# Example: Split players into top and other categories based on the criteria
top_players = list(top_batsmen.index)
other_players = [player for player in br['batter'].unique() if player not in top_players]

print("\nTop Players:", top_players)
print("\nOther Players:", other_players)

# Further analysis or splitting based on different criteria can be performed as needed.
# For instance, splitting based on roles, teams, etc.

# prompt: classify runs for each player against the team

# Assuming 'br' DataFrame is already loaded as in the previous code.

# Group data by batter and bowling team, then sum the batsman runs
runs_by_player_vs_team = br.groupby(['batter', 'bowling_team'])['batsman_runs'].sum().reset_index()

# Rename the columns for clarity
runs_by_player_vs_team.columns = ['batter', 'bowling_team', 'total_runs']

# Display the resulting DataFrame
print(runs_by_player_vs_team)


# Example: Classify runs based on thresholds (e.g., high, medium, low)

def classify_runs(runs):
    if runs >= 50:
        return 'High'
    elif runs >= 20:
        return 'Medium'
    else:
        return 'Low'

runs_by_player_vs_team['run_class'] = runs_by_player_vs_team['total_runs'].apply(classify_runs)

runs_by_player_vs_team

# prompt: take x has batter and bowling team and y has total runs

# Assuming 'runs_by_player_vs_team' DataFrame is already created as in the previous code.

# Access the 'batter' and 'bowling_team' columns as x, and 'total_runs' as y
x = runs_by_player_vs_team[['batter', 'bowling_team']]
y = runs_by_player_vs_team['total_runs']

print(x)
y

# prompt: built model and give accuracy

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder

# Load the data (assuming 'runs_by_player_vs_team' is already created)
# ... (your existing code to create runs_by_player_vs_team) ...

# Data Preprocessing: Encode categorical features
le = LabelEncoder()
x['batter'] = le.fit_transform(x['batter'])
x['bowling_team'] = le.fit_transform(x['bowling_team'])

# Define thresholds for run classification
def classify_runs(runs):
    if runs >= 50:
        return 2  # High
    elif runs >= 20:
        return 1  # Medium
    else:
        return 0  # Low

y = y.apply(classify_runs)

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# Initialize and train a Logistic Regression model
model = LogisticRegression(solver='liblinear', multi_class='auto')
model.fit(x_train, y_train)

# Make predictions on the test set
y_pred = model.predict(x_test)

# Calculate the accuracy of the model
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy of the Logistic Regression model: {accuracy}")

# prompt: create into pickel file

import pickle

# Assuming 'model', 'x', 'y', 'x_train', 'x_test', 'y_train', and 'y_test' are already defined as in your previous code.

# Create a dictionary to store the model and data
data_to_save = {
    'model': model,
    'x': x,
    'y': y,
    'x_train': x_train,
    'x_test': x_test,
    'y_train': y_train,
    'y_test': y_test,
    # Add other variables you want to save as needed
}

# Save the data to a pickle file
with open('model_and_data.pkl', 'wb') as file:
    pickle.dump(data_to_save, file)

print("Model and data saved to 'model_and_data.pkl'")